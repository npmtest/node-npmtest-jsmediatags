{"/home/travis/build/npmtest/node-npmtest-jsmediatags/test.js":"/* istanbul instrument in package npmtest_jsmediatags */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsmediatags/lib.npmtest_jsmediatags.js":"/* istanbul instrument in package npmtest_jsmediatags */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jsmediatags = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jsmediatags = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jsmediatags/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jsmediatags && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jsmediatags */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jsmediatags\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jsmediatags.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jsmediatags.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jsmediatags.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jsmediatags.__dirname + '/lib.npmtest_jsmediatags.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/jsmediatags.js":"'use strict';\n\nconst MediaFileReader = require(\"./MediaFileReader\");\nconst NodeFileReader = require(\"./NodeFileReader\");\nconst XhrFileReader = require(\"./XhrFileReader\");\nconst BlobFileReader = require(\"./BlobFileReader\");\nconst ArrayFileReader = require(\"./ArrayFileReader\");\nconst MediaTagReader = require(\"./MediaTagReader\");\nconst ID3v1TagReader = require(\"./ID3v1TagReader\");\nconst ID3v2TagReader = require(\"./ID3v2TagReader\");\nconst MP4TagReader = require(\"./MP4TagReader\");\n\nvar mediaFileReaders = [];\nvar mediaTagReaders = [];\n\nfunction read(location, callbacks) {\n  new Reader(location).read(callbacks);\n}\n\nfunction isRangeValid(range, fileSize) {\n  const invalidPositiveRange = range.offset >= 0 && range.offset + range.length >= fileSize;\n\n  const invalidNegativeRange = range.offset < 0 && (-range.offset > fileSize || range.offset + range.length > 0);\n\n  return !(invalidPositiveRange || invalidNegativeRange);\n}\n\nclass Reader {\n\n  constructor(file) {\n    this._file = file;\n  }\n\n  setTagsToRead(tagsToRead) {\n    this._tagsToRead = tagsToRead;\n    return this;\n  }\n\n  setFileReader(fileReader) {\n    this._fileReader = fileReader;\n    return this;\n  }\n\n  setTagReader(tagReader) {\n    this._tagReader = tagReader;\n    return this;\n  }\n\n  read(callbacks) {\n    var FileReader = this._getFileReader();\n    var fileReader = new FileReader(this._file);\n    var self = this;\n\n    fileReader.init({\n      onSuccess: function () {\n        self._getTagReader(fileReader, {\n          onSuccess: function (TagReader) {\n            new TagReader(fileReader).setTagsToRead(self._tagsToRead).read(callbacks);\n          },\n          onError: callbacks.onError\n        });\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _getFileReader() {\n    if (this._fileReader) {\n      return this._fileReader;\n    } else {\n      return this._findFileReader();\n    }\n  }\n\n  _findFileReader() {\n    for (var i = 0; i < mediaFileReaders.length; i++) {\n      if (mediaFileReaders[i].canReadFile(this._file)) {\n        return mediaFileReaders[i];\n      }\n    }\n\n    throw new Error(\"No suitable file reader found for \", this._file);\n  }\n\n  _getTagReader(fileReader, callbacks) {\n    if (this._tagReader) {\n      var tagReader = this._tagReader;\n      setTimeout(function () {\n        callbacks.onSuccess(tagReader);\n      }, 1);\n    } else {\n      this._findTagReader(fileReader, callbacks);\n    }\n  }\n\n  _findTagReader(fileReader, callbacks) {\n    // We don't want to make multiple fetches per tag reader to get the tag\n    // identifier. The strategy here is to combine all the tag identifier\n    // ranges into one and make a single fetch. This is particularly important\n    // in file readers that have expensive loads like the XHR one.\n    // However, with this strategy we run into the problem of loading the\n    // entire file because tag identifiers might be at the start or end of\n    // the file.\n    // To get around this we divide the tag readers into two categories, the\n    // ones that read their tag identifiers from the start of the file and the\n    // ones that read from the end of the file.\n    var tagReadersAtFileStart = [];\n    var tagReadersAtFileEnd = [];\n    var fileSize = fileReader.getSize();\n\n    for (var i = 0; i < mediaTagReaders.length; i++) {\n      var range = mediaTagReaders[i].getTagIdentifierByteRange();\n      if (!isRangeValid(range, fileSize)) {\n        continue;\n      }\n\n      if (range.offset >= 0 && range.offset < fileSize / 2 || range.offset < 0 && range.offset < -fileSize / 2) {\n        tagReadersAtFileStart.push(mediaTagReaders[i]);\n      } else {\n        tagReadersAtFileEnd.push(mediaTagReaders[i]);\n      }\n    }\n\n    var tagsLoaded = false;\n    var loadTagIdentifiersCallbacks = {\n      onSuccess: function () {\n        if (!tagsLoaded) {\n          // We're expecting to load two sets of tag identifiers. This flag\n          // indicates when the first one has been loaded.\n          tagsLoaded = true;\n          return;\n        }\n\n        for (var i = 0; i < mediaTagReaders.length; i++) {\n          var range = mediaTagReaders[i].getTagIdentifierByteRange();\n          if (!isRangeValid(range, fileSize)) {\n            continue;\n          }\n\n          try {\n            var tagIndentifier = fileReader.getBytesAt(range.offset >= 0 ? range.offset : range.offset + fileSize, range.length);\n          } catch (ex) {\n            if (callbacks.onError) {\n              callbacks.onError({\n                \"type\": \"fileReader\",\n                \"info\": ex.message\n              });\n              return;\n            }\n          }\n\n          if (mediaTagReaders[i].canReadTagFormat(tagIndentifier)) {\n            callbacks.onSuccess(mediaTagReaders[i]);\n            return;\n          }\n        }\n\n        if (callbacks.onError) {\n          callbacks.onError({\n            \"type\": \"tagFormat\",\n            \"info\": \"No suitable tag reader found\"\n          });\n        }\n      },\n      onError: callbacks.onError\n    };\n\n    this._loadTagIdentifierRanges(fileReader, tagReadersAtFileStart, loadTagIdentifiersCallbacks);\n    this._loadTagIdentifierRanges(fileReader, tagReadersAtFileEnd, loadTagIdentifiersCallbacks);\n  }\n\n  _loadTagIdentifierRanges(fileReader, tagReaders, callbacks) {\n    if (tagReaders.length === 0) {\n      // Force async\n      setTimeout(callbacks.onSuccess, 1);\n      return;\n    }\n\n    var tagIdentifierRange = [Number.MAX_VALUE, 0];\n    var fileSize = fileReader.getSize();\n\n    // Create a super set of all ranges so we can load them all at once.\n    // Might need to rethink this approach if there are tag ranges too far\n    // a part from each other. We're good for now though.\n    for (var i = 0; i < tagReaders.length; i++) {\n      var range = tagReaders[i].getTagIdentifierByteRange();\n      var start = range.offset >= 0 ? range.offset : range.offset + fileSize;\n      var end = start + range.length - 1;\n\n      tagIdentifierRange[0] = Math.min(start, tagIdentifierRange[0]);\n      tagIdentifierRange[1] = Math.max(end, tagIdentifierRange[1]);\n    }\n\n    fileReader.loadRange(tagIdentifierRange, callbacks);\n  }\n}\n\nclass Config {\n  static addFileReader(fileReader) {\n    mediaFileReaders.push(fileReader);\n    return Config;\n  }\n\n  static addTagReader(tagReader) {\n    mediaTagReaders.push(tagReader);\n    return Config;\n  }\n\n  static removeTagReader(tagReader) {\n    var tagReaderIx = mediaTagReaders.indexOf(tagReader);\n\n    if (tagReaderIx >= 0) {\n      mediaTagReaders.splice(tagReaderIx, 1);\n    }\n\n    return Config;\n  }\n\n  static EXPERIMENTAL_avoidHeadRequests() {\n    XhrFileReader.setConfig({\n      avoidHeadRequests: true\n    });\n  }\n\n  static setDisallowedXhrHeaders(disallowedXhrHeaders) {\n    XhrFileReader.setConfig({\n      disallowedXhrHeaders: disallowedXhrHeaders\n    });\n  }\n\n  static setXhrTimeoutInSec(timeoutInSec) {\n    XhrFileReader.setConfig({\n      timeoutInSec: timeoutInSec\n    });\n  }\n}\n\nConfig.addFileReader(XhrFileReader).addFileReader(BlobFileReader).addFileReader(ArrayFileReader).addTagReader(ID3v2TagReader).addTagReader(ID3v1TagReader).addTagReader(MP4TagReader);\n\nif (typeof process !== \"undefined\") {\n  Config.addFileReader(NodeFileReader);\n}\n\nmodule.exports = {\n  \"read\": read,\n  \"Reader\": Reader,\n  \"Config\": Config\n};","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/MediaFileReader.js":"'use strict';\n\nconst StringUtils = require('./StringUtils');\n\nclass MediaFileReader {\n\n  constructor() {\n    this._isInitialized = false;\n    this._size = 0;\n  }\n\n  /**\n   * Decides if this media file reader is able to read the given file.\n   */\n  static canReadFile(file) {\n    throw new Error(\"Must implement canReadFile function\");\n  }\n\n  /**\n   * This function needs to be called before any other function.\n   * Loads the necessary initial information from the file.\n   */\n  init(callbacks) {\n    var self = this;\n\n    if (this._isInitialized) {\n      setTimeout(callbacks.onSuccess, 1);\n    } else {\n      return this._init({\n        onSuccess: function () {\n          self._isInitialized = true;\n          callbacks.onSuccess();\n        },\n        onError: callbacks.onError\n      });\n    }\n  }\n\n  _init(callbacks) {\n    throw new Error(\"Must implement init function\");\n  }\n\n  /**\n   * @param range The start and end indexes of the range to load.\n   *        Ex: [0, 7] load bytes 0 to 7 inclusive.\n   */\n  loadRange(range, callbacks) {\n    throw new Error(\"Must implement loadRange function\");\n  }\n\n  /**\n   * @return The size of the file in bytes.\n   */\n  getSize() {\n    if (!this._isInitialized) {\n      throw new Error(\"init() must be called first.\");\n    }\n\n    return this._size;\n  }\n\n  getByteAt(offset) {\n    throw new Error(\"Must implement getByteAt function\");\n  }\n\n  getBytesAt(offset, length) {\n    var bytes = new Array(length);\n    for (var i = 0; i < length; i++) {\n      bytes[i] = this.getByteAt(offset + i);\n    }\n    return bytes;\n  }\n\n  isBitSetAt(offset, bit) {\n    var iByte = this.getByteAt(offset);\n    return (iByte & 1 << bit) != 0;\n  }\n\n  getSByteAt(offset) {\n    var iByte = this.getByteAt(offset);\n    if (iByte > 127) {\n      return iByte - 256;\n    } else {\n      return iByte;\n    }\n  }\n\n  getShortAt(offset, isBigEndian) {\n    var iShort = isBigEndian ? (this.getByteAt(offset) << 8) + this.getByteAt(offset + 1) : (this.getByteAt(offset + 1) << 8) + this.getByteAt(offset);\n    if (iShort < 0) {\n      iShort += 65536;\n    }\n    return iShort;\n  }\n\n  getSShortAt(offset, isBigEndian) {\n    var iUShort = this.getShortAt(offset, isBigEndian);\n    if (iUShort > 32767) {\n      return iUShort - 65536;\n    } else {\n      return iUShort;\n    }\n  }\n\n  getLongAt(offset, isBigEndian) {\n    var iByte1 = this.getByteAt(offset),\n        iByte2 = this.getByteAt(offset + 1),\n        iByte3 = this.getByteAt(offset + 2),\n        iByte4 = this.getByteAt(offset + 3);\n\n    var iLong = isBigEndian ? (((iByte1 << 8) + iByte2 << 8) + iByte3 << 8) + iByte4 : (((iByte4 << 8) + iByte3 << 8) + iByte2 << 8) + iByte1;\n\n    if (iLong < 0) {\n      iLong += 4294967296;\n    }\n\n    return iLong;\n  }\n\n  getSLongAt(offset, isBigEndian) {\n    var iULong = this.getLongAt(offset, isBigEndian);\n\n    if (iULong > 2147483647) {\n      return iULong - 4294967296;\n    } else {\n      return iULong;\n    }\n  }\n\n  getInteger24At(offset, isBigEndian) {\n    var iByte1 = this.getByteAt(offset),\n        iByte2 = this.getByteAt(offset + 1),\n        iByte3 = this.getByteAt(offset + 2);\n\n    var iInteger = isBigEndian ? ((iByte1 << 8) + iByte2 << 8) + iByte3 : ((iByte3 << 8) + iByte2 << 8) + iByte1;\n\n    if (iInteger < 0) {\n      iInteger += 16777216;\n    }\n\n    return iInteger;\n  }\n\n  getStringAt(offset, length) {\n    var string = [];\n    for (var i = offset, j = 0; i < offset + length; i++, j++) {\n      string[j] = String.fromCharCode(this.getByteAt(i));\n    }\n    return string.join(\"\");\n  }\n\n  getStringWithCharsetAt(offset, length, charset) {\n    var bytes = this.getBytesAt(offset, length);\n    var string;\n\n    switch ((charset || '').toLowerCase()) {\n      case \"utf-16\":\n      case \"utf-16le\":\n      case \"utf-16be\":\n        string = StringUtils.readUTF16String(bytes, charset === \"utf-16be\");\n        break;\n\n      case \"utf-8\":\n        string = StringUtils.readUTF8String(bytes);\n        break;\n\n      default:\n        string = StringUtils.readNullTerminatedString(bytes);\n        break;\n    }\n\n    return string;\n  }\n\n  getCharAt(offset) {\n    return String.fromCharCode(this.getByteAt(offset));\n  }\n\n  /**\n   * The ID3v2 tag/frame size is encoded with four bytes where the most\n   * significant bit (bit 7) is set to zero in every byte, making a total of 28\n   * bits. The zeroed bits are ignored, so a 257 bytes long tag is represented\n   * as $00 00 02 01.\n   */\n  getSynchsafeInteger32At(offset) {\n    var size1 = this.getByteAt(offset);\n    var size2 = this.getByteAt(offset + 1);\n    var size3 = this.getByteAt(offset + 2);\n    var size4 = this.getByteAt(offset + 3);\n    // 0x7f = 0b01111111\n    var size = size4 & 0x7f | (size3 & 0x7f) << 7 | (size2 & 0x7f) << 14 | (size1 & 0x7f) << 21;\n\n    return size;\n  }\n}\n\nmodule.exports = MediaFileReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/StringUtils.js":"'use strict';\n\nclass InternalDecodedString {\n\n  constructor(value, bytesReadCount) {\n    this._value = value;\n    this.bytesReadCount = bytesReadCount;\n    this.length = value.length;\n  }\n\n  toString() {\n    return this._value;\n  }\n}\n\nvar StringUtils = {\n  readUTF16String: function (bytes, bigEndian, maxBytes) {\n    var ix = 0;\n    var offset1 = 1,\n        offset2 = 0;\n\n    maxBytes = Math.min(maxBytes || bytes.length, bytes.length);\n\n    if (bytes[0] == 0xFE && bytes[1] == 0xFF) {\n      bigEndian = true;\n      ix = 2;\n    } else if (bytes[0] == 0xFF && bytes[1] == 0xFE) {\n      bigEndian = false;\n      ix = 2;\n    }\n    if (bigEndian) {\n      offset1 = 0;\n      offset2 = 1;\n    }\n\n    var arr = [];\n    for (var j = 0; ix < maxBytes; j++) {\n      var byte1 = bytes[ix + offset1];\n      var byte2 = bytes[ix + offset2];\n      var word1 = (byte1 << 8) + byte2;\n      ix += 2;\n      if (word1 == 0x0000) {\n        break;\n      } else if (byte1 < 0xD8 || byte1 >= 0xE0) {\n        arr[j] = String.fromCharCode(word1);\n      } else {\n        var byte3 = bytes[ix + offset1];\n        var byte4 = bytes[ix + offset2];\n        var word2 = (byte3 << 8) + byte4;\n        ix += 2;\n        arr[j] = String.fromCharCode(word1, word2);\n      }\n    }\n    return new InternalDecodedString(arr.join(\"\"), ix);\n  },\n\n  readUTF8String: function (bytes, maxBytes) {\n    var ix = 0;\n    maxBytes = Math.min(maxBytes || bytes.length, bytes.length);\n\n    if (bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF) {\n      ix = 3;\n    }\n\n    var arr = [];\n    for (var j = 0; ix < maxBytes; j++) {\n      var byte1 = bytes[ix++];\n      if (byte1 == 0x00) {\n        break;\n      } else if (byte1 < 0x80) {\n        arr[j] = String.fromCharCode(byte1);\n      } else if (byte1 >= 0xC2 && byte1 < 0xE0) {\n        var byte2 = bytes[ix++];\n        arr[j] = String.fromCharCode(((byte1 & 0x1F) << 6) + (byte2 & 0x3F));\n      } else if (byte1 >= 0xE0 && byte1 < 0xF0) {\n        var byte2 = bytes[ix++];\n        var byte3 = bytes[ix++];\n        arr[j] = String.fromCharCode(((byte1 & 0xFF) << 12) + ((byte2 & 0x3F) << 6) + (byte3 & 0x3F));\n      } else if (byte1 >= 0xF0 && byte1 < 0xF5) {\n        var byte2 = bytes[ix++];\n        var byte3 = bytes[ix++];\n        var byte4 = bytes[ix++];\n        var codepoint = ((byte1 & 0x07) << 18) + ((byte2 & 0x3F) << 12) + ((byte3 & 0x3F) << 6) + (byte4 & 0x3F) - 0x10000;\n        arr[j] = String.fromCharCode((codepoint >> 10) + 0xD800, (codepoint & 0x3FF) + 0xDC00);\n      }\n    }\n    return new InternalDecodedString(arr.join(\"\"), ix);\n  },\n\n  readNullTerminatedString: function (bytes, maxBytes) {\n    var arr = [];\n    maxBytes = maxBytes || bytes.length;\n    for (var i = 0; i < maxBytes;) {\n      var byte1 = bytes[i++];\n      if (byte1 == 0x00) {\n        break;\n      }\n      arr[i - 1] = String.fromCharCode(byte1);\n    }\n    return new InternalDecodedString(arr.join(\"\"), i);\n  }\n};\n\nmodule.exports = StringUtils;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/NodeFileReader.js":"'use strict';\n\nconst fs = require('fs');\n\nconst ChunkedFileData = require('./ChunkedFileData');\nconst MediaFileReader = require('./MediaFileReader');\n\nclass NodeFileReader extends MediaFileReader {\n\n  constructor(path) {\n    super();\n    this._path = path;\n    this._fileData = new ChunkedFileData();\n  }\n\n  static canReadFile(file) {\n    return typeof file === 'string' && !/^[a-z]+:\\/\\//i.test(file);\n  }\n\n  getByteAt(offset) {\n    return this._fileData.getByteAt(offset);\n  }\n\n  _init(callbacks) {\n    var self = this;\n\n    fs.stat(self._path, function (err, stats) {\n      if (err) {\n        if (callbacks.onError) {\n          callbacks.onError({ \"type\": \"fs\", \"info\": err });\n        }\n      } else {\n        self._size = stats.size;\n        callbacks.onSuccess();\n      }\n    });\n  }\n\n  loadRange(range, callbacks) {\n    var fd = -1;\n    var self = this;\n    var fileData = this._fileData;\n\n    var length = range[1] - range[0] + 1;\n    var onSuccess = callbacks.onSuccess;\n    var onError = callbacks.onError || function () {};\n\n    if (fileData.hasDataRange(range[0], range[1])) {\n      process.nextTick(onSuccess);\n      return;\n    }\n\n    var readData = function (err, _fd) {\n      if (err) {\n        onError({ \"type\": \"fs\", \"info\": err });\n        return;\n      }\n\n      fd = _fd;\n      // TODO: Should create a pool of Buffer objects across all instances of\n      //       NodeFileReader. This is fine for now.\n      var buffer = new Buffer(length);\n      fs.read(_fd, buffer, 0, length, range[0], processData);\n    };\n\n    var processData = function (err, bytesRead, buffer) {\n      fs.close(fd, function (err) {\n        if (err) {\n          console.error(err);\n        }\n      });\n\n      if (err) {\n        onError({ \"type\": \"fs\", \"info\": err });\n        return;\n      }\n\n      storeBuffer(buffer);\n      onSuccess();\n    };\n\n    var storeBuffer = function (buffer) {\n      var data = Array.prototype.slice.call(buffer, 0, length);\n      fileData.addData(range[0], data);\n    };\n\n    fs.open(this._path, \"r\", undefined, readData);\n  }\n}\n\nmodule.exports = NodeFileReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ChunkedFileData.js":"/**\n * This class represents a file that might not have all its data loaded yet.\n * It is used when loading the entire file is not an option because it's too\n * expensive. Instead, parts of the file are loaded and added only when needed.\n * From a reading point of view is as if the entire file is loaded. The\n * exception is when the data is not available yet, an error will be thrown.\n * This class does not load the data, it just manages it. It provides operations\n * to add and read data from the file.\n *\n * \n */\n'use strict';\n\nconst NOT_FOUND = -1;\n\nclass ChunkedFileData {\n  // $FlowIssue - get/set properties not yet supported\n  static get NOT_FOUND() {\n    return NOT_FOUND;\n  }\n\n\n  constructor() {\n    this._fileData = [];\n  }\n\n  /**\n   * Adds data to the file storage at a specific offset.\n   */\n  addData(offset, data) {\n    var offsetEnd = offset + data.length - 1;\n    var chunkRange = this._getChunkRange(offset, offsetEnd);\n\n    if (chunkRange.startIx === NOT_FOUND) {\n      this._fileData.splice(chunkRange.insertIx || 0, 0, {\n        offset: offset,\n        data: data\n      });\n    } else {\n      // If the data to add collides with existing chunks we prepend and\n      // append data from the half colliding chunks to make the collision at\n      // 100%. The new data can then replace all the colliding chunkes.\n      var firstChunk = this._fileData[chunkRange.startIx];\n      var lastChunk = this._fileData[chunkRange.endIx];\n      var needsPrepend = offset > firstChunk.offset;\n      var needsAppend = offsetEnd < lastChunk.offset + lastChunk.data.length - 1;\n\n      var chunk = {\n        offset: Math.min(offset, firstChunk.offset),\n        data: data\n      };\n\n      if (needsPrepend) {\n        var slicedData = this._sliceData(firstChunk.data, 0, offset - firstChunk.offset);\n        chunk.data = this._concatData(slicedData, data);\n      }\n\n      if (needsAppend) {\n        // Use the lastChunk because the slice logic is easier to handle.\n        var slicedData = this._sliceData(chunk.data, 0, lastChunk.offset - chunk.offset);\n        chunk.data = this._concatData(slicedData, lastChunk.data);\n      }\n\n      this._fileData.splice(chunkRange.startIx, chunkRange.endIx - chunkRange.startIx + 1, chunk);\n    }\n  }\n\n  _concatData(dataA, dataB) {\n    // TypedArrays don't support concat.\n    if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(dataA)) {\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\n      var dataAandB = new dataA.constructor(dataA.length + dataB.length);\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\n      dataAandB.set(dataA, 0);\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\n      dataAandB.set(dataB, dataA.length);\n      return dataAandB;\n    } else {\n      // $FlowIssue - flow thinks dataAandB is a TypedArray but it's not\n      return dataA.concat(dataB);\n    }\n  }\n\n  _sliceData(data, begin, end) {\n    // Some TypeArray implementations do not support slice yet.\n    if (data.slice) {\n      return data.slice(begin, end);\n    } else {\n      // $FlowIssue - flow thinks data is a string but it's not\n      return data.subarray(begin, end);\n    }\n  }\n\n  /**\n   * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.\n   * When a chunk is adjacent to the offset we still consider it part of the\n   * range (this is the situation of offsetStart-1 or offsetEnd+1).\n   * When no chunks are found `insertIx` denotes the index where the data\n   * should be inserted in the data list (startIx == NOT_FOUND and endIX ==\n   * NOT_FOUND).\n   */\n  _getChunkRange(offsetStart, offsetEnd) {\n    var startChunkIx = NOT_FOUND;\n    var endChunkIx = NOT_FOUND;\n    var insertIx = 0;\n\n    // Could use binary search but not expecting that many blocks to exist.\n    for (var i = 0; i < this._fileData.length; i++, insertIx = i) {\n      var chunkOffsetStart = this._fileData[i].offset;\n      var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n\n      if (offsetEnd < chunkOffsetStart - 1) {\n        // This offset range doesn't overlap with any chunks.\n        break;\n      }\n      // If it is adjacent we still consider it part of the range because\n      // we're going end up with a single block with all contiguous data.\n      if (offsetStart <= chunkOffsetEnd + 1 && offsetEnd >= chunkOffsetStart - 1) {\n        startChunkIx = i;\n        break;\n      }\n    }\n\n    // No starting chunk was found, meaning that the offset is either before\n    // or after the current stored chunks.\n    if (startChunkIx === NOT_FOUND) {\n      return {\n        startIx: NOT_FOUND,\n        endIx: NOT_FOUND,\n        insertIx: insertIx\n      };\n    }\n\n    // Find the ending chunk.\n    for (var i = startChunkIx; i < this._fileData.length; i++) {\n      var chunkOffsetStart = this._fileData[i].offset;\n      var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\n\n      if (offsetEnd >= chunkOffsetStart - 1) {\n        // Candidate for the end chunk, it doesn't mean it is yet.\n        endChunkIx = i;\n      }\n      if (offsetEnd <= chunkOffsetEnd + 1) {\n        break;\n      }\n    }\n\n    if (endChunkIx === NOT_FOUND) {\n      endChunkIx = startChunkIx;\n    }\n\n    return {\n      startIx: startChunkIx,\n      endIx: endChunkIx\n    };\n  }\n\n  hasDataRange(offsetStart, offsetEnd) {\n    for (var i = 0; i < this._fileData.length; i++) {\n      var chunk = this._fileData[i];\n      if (offsetEnd < chunk.offset) {\n        return false;\n      }\n\n      if (offsetStart >= chunk.offset && offsetEnd < chunk.offset + chunk.data.length) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getByteAt(offset) {\n    var dataChunk;\n\n    for (var i = 0; i < this._fileData.length; i++) {\n      var dataChunkStart = this._fileData[i].offset;\n      var dataChunkEnd = dataChunkStart + this._fileData[i].data.length - 1;\n\n      if (offset >= dataChunkStart && offset <= dataChunkEnd) {\n        dataChunk = this._fileData[i];\n        break;\n      }\n    }\n\n    if (dataChunk) {\n      return dataChunk.data[offset - dataChunk.offset];\n    }\n\n    throw new Error(\"Offset \" + offset + \" hasn't been loaded yet.\");\n  }\n}\n\nmodule.exports = ChunkedFileData;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/XhrFileReader.js":"'use strict';\n\nconst ChunkedFileData = require('./ChunkedFileData');\nconst MediaFileReader = require('./MediaFileReader');\n\nconst CHUNK_SIZE = 1024;\n\nclass XhrFileReader extends MediaFileReader {\n\n  constructor(url) {\n    super();\n    this._url = url;\n    this._fileData = new ChunkedFileData();\n  }\n\n  static canReadFile(file) {\n    return typeof file === 'string' && /^[a-z]+:\\/\\//i.test(file);\n  }\n\n  static setConfig(config) {\n    for (var key in config) if (config.hasOwnProperty(key)) {\n      this._config[key] = config[key];\n    }\n\n    var disallowedXhrHeaders = this._config.disallowedXhrHeaders;\n    for (var i = 0; i < disallowedXhrHeaders.length; i++) {\n      disallowedXhrHeaders[i] = disallowedXhrHeaders[i].toLowerCase();\n    }\n  }\n\n  _init(callbacks) {\n    if (XhrFileReader._config.avoidHeadRequests) {\n      this._fetchSizeWithGetRequest(callbacks);\n    } else {\n      this._fetchSizeWithHeadRequest(callbacks);\n    }\n  }\n\n  _fetchSizeWithHeadRequest(callbacks) {\n    var self = this;\n\n    this._makeXHRRequest(\"HEAD\", null, {\n      onSuccess: function (xhr) {\n        var contentLength = self._parseContentLength(xhr);\n        if (contentLength) {\n          self._size = contentLength;\n          callbacks.onSuccess();\n        } else {\n          // Content-Length not provided by the server, fallback to\n          // GET requests.\n          self._fetchSizeWithGetRequest(callbacks);\n        }\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _fetchSizeWithGetRequest(callbacks) {\n    var self = this;\n    var range = this._roundRangeToChunkMultiple([0, 0]);\n\n    this._makeXHRRequest(\"GET\", range, {\n      onSuccess: function (xhr) {\n        var contentRange = self._parseContentRange(xhr);\n        var data = self._getXhrResponseContent(xhr);\n\n        if (contentRange) {\n          if (contentRange.instanceLength == null) {\n            // Last resort, server is not able to tell us the content length,\n            // need to fetch entire file then.\n            self._fetchEntireFile(callbacks);\n            return;\n          }\n          self._size = contentRange.instanceLength;\n        } else {\n          // Range request not supported, we got the entire file\n          self._size = data.length;\n        }\n\n        self._fileData.addData(0, data);\n        callbacks.onSuccess();\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _fetchEntireFile(callbacks) {\n    var self = this;\n    this._makeXHRRequest(\"GET\", null, {\n      onSuccess: function (xhr) {\n        var data = self._getXhrResponseContent(xhr);\n        self._size = data.length;\n        self._fileData.addData(0, data);\n        callbacks.onSuccess();\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _getXhrResponseContent(xhr) {\n    return xhr.responseBody || xhr.responseText || \"\";\n  }\n\n  _parseContentLength(xhr) {\n    var contentLength = this._getResponseHeader(xhr, \"Content-Length\");\n\n    if (contentLength == null) {\n      return contentLength;\n    } else {\n      return parseInt(contentLength, 10);\n    }\n  }\n\n  _parseContentRange(xhr) {\n    var contentRange = this._getResponseHeader(xhr, \"Content-Range\");\n\n    if (contentRange) {\n      var parsedContentRange = contentRange.match(/bytes (\\d+)-(\\d+)\\/(?:(\\d+)|\\*)/i);\n      if (!parsedContentRange) {\n        throw new Error(\"FIXME: Unknown Content-Range syntax: \", contentRange);\n      }\n\n      return {\n        firstBytePosition: parseInt(parsedContentRange[1], 10),\n        lastBytePosition: parseInt(parsedContentRange[2], 10),\n        instanceLength: parsedContentRange[3] ? parseInt(parsedContentRange[3], 10) : null\n      };\n    } else {\n      return null;\n    }\n  }\n\n  loadRange(range, callbacks) {\n    var self = this;\n\n    if (self._fileData.hasDataRange(range[0], Math.min(self._size, range[1]))) {\n      setTimeout(callbacks.onSuccess, 1);\n      return;\n    }\n\n    // Always download in multiples of CHUNK_SIZE. If we're going to make a\n    // request might as well get a chunk that makes sense. The big cost is\n    // establishing the connection so getting 10bytes or 1K doesn't really\n    // make a difference.\n    range = this._roundRangeToChunkMultiple(range);\n\n    // Upper range should not be greater than max file size\n    range[1] = Math.min(self._size, range[1]);\n\n    this._makeXHRRequest(\"GET\", range, {\n      onSuccess: function (xhr) {\n        var data = self._getXhrResponseContent(xhr);\n        self._fileData.addData(range[0], data);\n        callbacks.onSuccess();\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _roundRangeToChunkMultiple(range) {\n    var length = range[1] - range[0] + 1;\n    var newLength = Math.ceil(length / CHUNK_SIZE) * CHUNK_SIZE;\n    return [range[0], range[0] + newLength - 1];\n  }\n\n  _makeXHRRequest(method, range, callbacks) {\n    var xhr = this._createXHRObject();\n\n    var onXHRLoad = function () {\n      // 200 - OK\n      // 206 - Partial Content\n      // $FlowIssue - xhr will not be null here\n      if (xhr.status === 200 || xhr.status === 206) {\n        callbacks.onSuccess(xhr);\n      } else if (callbacks.onError) {\n        callbacks.onError({\n          \"type\": \"xhr\",\n          \"info\": \"Unexpected HTTP status \" + xhr.status + \".\",\n          \"xhr\": xhr\n        });\n      }\n      xhr = null;\n    };\n\n    if (typeof xhr.onload !== 'undefined') {\n      xhr.onload = onXHRLoad;\n      xhr.onerror = function () {\n        if (callbacks.onError) {\n          callbacks.onError({\n            \"type\": \"xhr\",\n            \"info\": \"Generic XHR error, check xhr object.\",\n            \"xhr\": xhr\n          });\n        }\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        // $FlowIssue - xhr will not be null here\n        if (xhr.readyState === 4) {\n          onXHRLoad();\n        }\n      };\n    }\n\n    if (XhrFileReader._config.timeoutInSec) {\n      xhr.timeout = XhrFileReader._config.timeoutInSec * 1000;\n      xhr.ontimeout = function () {\n        if (callbacks.onError) {\n          callbacks.onError({\n            \"type\": \"xhr\",\n            // $FlowIssue - xhr.timeout will not be null\n            \"info\": \"Timeout after \" + xhr.timeout / 1000 + \"s. Use jsmediatags.Config.setXhrTimeout to override.\",\n            \"xhr\": xhr\n          });\n        }\n      };\n    }\n\n    xhr.open(method, this._url);\n    xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n    if (range) {\n      this._setRequestHeader(xhr, \"Range\", \"bytes=\" + range[0] + \"-\" + range[1]);\n    }\n    this._setRequestHeader(xhr, \"If-Modified-Since\", \"Sat, 01 Jan 1970 00:00:00 GMT\");\n    xhr.send(null);\n  }\n\n  _setRequestHeader(xhr, headerName, headerValue) {\n    if (XhrFileReader._config.disallowedXhrHeaders.indexOf(headerName.toLowerCase()) < 0) {\n      xhr.setRequestHeader(headerName, headerValue);\n    }\n  }\n\n  _hasResponseHeader(xhr, headerName) {\n    var allResponseHeaders = xhr.getAllResponseHeaders();\n\n    if (!allResponseHeaders) {\n      return false;\n    }\n\n    var headers = allResponseHeaders.split(\"\\r\\n\");\n    var headerNames = [];\n    for (var i = 0; i < headers.length; i++) {\n      headerNames[i] = headers[i].split(\":\")[0].toLowerCase();\n    }\n\n    return headerNames.indexOf(headerName.toLowerCase()) >= 0;\n  }\n\n  _getResponseHeader(xhr, headerName) {\n    if (!this._hasResponseHeader(xhr, headerName)) {\n      return null;\n    }\n\n    return xhr.getResponseHeader(headerName);\n  }\n\n  getByteAt(offset) {\n    var character = this._fileData.getByteAt(offset);\n    return character.charCodeAt(0) & 0xff;\n  }\n\n  _createXHRObject() {\n    if (typeof window === \"undefined\") {\n      // $FlowIssue - flow is not able to recognize this module.\n      return new (require(\"xhr2\").XMLHttpRequest)();\n    }\n\n    if (window.XMLHttpRequest) {\n      return new window.XMLHttpRequest();\n    }\n\n    throw new Error(\"XMLHttpRequest is not supported\");\n  }\n}\n\nXhrFileReader._config = {\n  avoidHeadRequests: false,\n  disallowedXhrHeaders: [],\n  timeoutInSec: 30\n};\n\nmodule.exports = XhrFileReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/BlobFileReader.js":"'use strict';\n\nconst ChunkedFileData = require('./ChunkedFileData');\nconst MediaFileReader = require('./MediaFileReader');\n\nclass BlobFileReader extends MediaFileReader {\n\n  constructor(blob) {\n    super();\n    this._blob = blob;\n    this._fileData = new ChunkedFileData();\n  }\n\n  static canReadFile(file) {\n    return typeof Blob !== \"undefined\" && file instanceof Blob ||\n    // File extends Blob but it seems that File instanceof Blob doesn't\n    // quite work as expected in Cordova/PhoneGap.\n    typeof File !== \"undefined\" && file instanceof File;\n  }\n\n  _init(callbacks) {\n    this._size = this._blob.size;\n    setTimeout(callbacks.onSuccess, 1);\n  }\n\n  loadRange(range, callbacks) {\n    var self = this;\n    // $FlowIssue - flow isn't aware of mozSlice or webkitSlice\n    var blobSlice = this._blob.slice || this._blob.mozSlice || this._blob.webkitSlice;\n    var blob = blobSlice.call(this._blob, range[0], range[1] + 1);\n    var browserFileReader = new FileReader();\n\n    browserFileReader.onloadend = function (event) {\n      var intArray = new Uint8Array(browserFileReader.result);\n      self._fileData.addData(range[0], intArray);\n      callbacks.onSuccess();\n    };\n    browserFileReader.onerror = browserFileReader.onabort = function (event) {\n      if (callbacks.onError) {\n        callbacks.onError({ \"type\": \"blob\", \"info\": browserFileReader.error });\n      }\n    };\n\n    browserFileReader.readAsArrayBuffer(blob);\n  }\n\n  getByteAt(offset) {\n    return this._fileData.getByteAt(offset);\n  }\n}\n\nmodule.exports = BlobFileReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ArrayFileReader.js":"'use strict';\n\nvar MediaFileReader = require('./MediaFileReader');\n\nclass ArrayFileReader extends MediaFileReader {\n\n  constructor(array) {\n    super();\n    this._array = array;\n    this._size = array.length;\n    this._isInitialized = true;\n  }\n\n  static canReadFile(file) {\n    return Array.isArray(file) || typeof Buffer === 'function' && Buffer.isBuffer(file);\n  }\n\n  init(callbacks) {\n    setTimeout(callbacks.onSuccess, 0);\n  }\n\n  loadRange(range, callbacks) {\n    setTimeout(callbacks.onSuccess, 0);\n  }\n\n  getByteAt(offset) {\n    return this._array[offset];\n  }\n}\n\nmodule.exports = ArrayFileReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/MediaTagReader.js":"'use strict';\n\nconst MediaFileReader = require('./MediaFileReader');\n\nclass MediaTagReader {\n\n  constructor(mediaFileReader) {\n    this._mediaFileReader = mediaFileReader;\n    this._tags = null;\n  }\n\n  /**\n   * Returns the byte range that needs to be loaded and fed to\n   * _canReadTagFormat in order to identify if the file contains tag\n   * information that can be read.\n   */\n  static getTagIdentifierByteRange() {\n    throw new Error(\"Must implement\");\n  }\n\n  /**\n   * Given a tag identifier (read from the file byte positions speficied by\n   * getTagIdentifierByteRange) this function checks if it can read the tag\n   * format or not.\n   */\n  static canReadTagFormat(tagIdentifier) {\n    throw new Error(\"Must implement\");\n  }\n\n  setTagsToRead(tags) {\n    this._tags = tags;\n    return this;\n  }\n\n  read(callbacks) {\n    var self = this;\n\n    this._mediaFileReader.init({\n      onSuccess: function () {\n        self._loadData(self._mediaFileReader, {\n          onSuccess: function () {\n            try {\n              var tags = self._parseData(self._mediaFileReader, self._tags);\n            } catch (ex) {\n              if (callbacks.onError) {\n                callbacks.onError({\n                  \"type\": \"parseData\",\n                  \"info\": ex.message\n                });\n                return;\n              }\n            }\n\n            // TODO: destroy mediaFileReader\n            callbacks.onSuccess(tags);\n          },\n          onError: callbacks.onError\n        });\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  getShortcuts() {\n    return {};\n  }\n\n  /**\n   * Load the necessary bytes from the media file.\n   */\n  _loadData(mediaFileReader, callbacks) {\n    throw new Error(\"Must implement _loadData function\");\n  }\n\n  /**\n   * Parse the loaded data to read the media tags.\n   */\n  _parseData(mediaFileReader, tags) {\n    throw new Error(\"Must implement _parseData function\");\n  }\n\n  _expandShortcutTags(tagsWithShortcuts) {\n    if (!tagsWithShortcuts) {\n      return null;\n    }\n\n    var tags = [];\n    var shortcuts = this.getShortcuts();\n    for (var i = 0, tagOrShortcut; tagOrShortcut = tagsWithShortcuts[i]; i++) {\n      tags = tags.concat(shortcuts[tagOrShortcut] || [tagOrShortcut]);\n    }\n\n    return tags;\n  }\n}\n\nmodule.exports = MediaTagReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ID3v1TagReader.js":"'use strict';\n\nvar MediaTagReader = require('./MediaTagReader');\nvar MediaFileReader = require('./MediaFileReader');\n\nclass ID3v1TagReader extends MediaTagReader {\n  static getTagIdentifierByteRange() {\n    // The identifier is TAG and is at offset: -128. However, to avoid a\n    // fetch for the tag identifier and another for the data, we load the\n    // entire data since it's so small.\n    return {\n      offset: -128,\n      length: 128\n    };\n  }\n\n  static canReadTagFormat(tagIdentifier) {\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 3));\n    return id === \"TAG\";\n  }\n\n  _loadData(mediaFileReader, callbacks) {\n    var fileSize = mediaFileReader.getSize();\n    mediaFileReader.loadRange([fileSize - 128, fileSize - 1], callbacks);\n  }\n\n  _parseData(data, tags) {\n    var offset = data.getSize() - 128;\n\n    var title = data.getStringWithCharsetAt(offset + 3, 30).toString();\n    var artist = data.getStringWithCharsetAt(offset + 33, 30).toString();\n    var album = data.getStringWithCharsetAt(offset + 63, 30).toString();\n    var year = data.getStringWithCharsetAt(offset + 93, 4).toString();\n\n    var trackFlag = data.getByteAt(offset + 97 + 28);\n    var track = data.getByteAt(offset + 97 + 29);\n    if (trackFlag == 0 && track != 0) {\n      var version = \"1.1\";\n      var comment = data.getStringWithCharsetAt(offset + 97, 28).toString();\n    } else {\n      var version = \"1.0\";\n      var comment = data.getStringWithCharsetAt(offset + 97, 30).toString();\n      track = 0;\n    }\n\n    var genreIdx = data.getByteAt(offset + 97 + 30);\n    if (genreIdx < 255) {\n      var genre = GENRES[genreIdx];\n    } else {\n      var genre = \"\";\n    }\n\n    var tag = {\n      \"type\": \"ID3\",\n      \"version\": version,\n      \"tags\": {\n        \"title\": title,\n        \"artist\": artist,\n        \"album\": album,\n        \"year\": year,\n        \"comment\": comment,\n        \"genre\": genre\n      }\n    };\n\n    if (track) {\n      // $FlowIssue - flow is not happy with adding properties\n      tag.tags.track = track;\n    }\n\n    return tag;\n  }\n}\n\nvar GENRES = [\"Blues\", \"Classic Rock\", \"Country\", \"Dance\", \"Disco\", \"Funk\", \"Grunge\", \"Hip-Hop\", \"Jazz\", \"Metal\", \"New Age\", \"Oldies\", \"Other\", \"Pop\", \"R&B\", \"Rap\", \"Reggae\", \"Rock\", \"Techno\", \"Industrial\", \"Alternative\", \"Ska\", \"Death Metal\", \"Pranks\", \"Soundtrack\", \"Euro-Techno\", \"Ambient\", \"Trip-Hop\", \"Vocal\", \"Jazz+Funk\", \"Fusion\", \"Trance\", \"Classical\", \"Instrumental\", \"Acid\", \"House\", \"Game\", \"Sound Clip\", \"Gospel\", \"Noise\", \"AlternRock\", \"Bass\", \"Soul\", \"Punk\", \"Space\", \"Meditative\", \"Instrumental Pop\", \"Instrumental Rock\", \"Ethnic\", \"Gothic\", \"Darkwave\", \"Techno-Industrial\", \"Electronic\", \"Pop-Folk\", \"Eurodance\", \"Dream\", \"Southern Rock\", \"Comedy\", \"Cult\", \"Gangsta\", \"Top 40\", \"Christian Rap\", \"Pop/Funk\", \"Jungle\", \"Native American\", \"Cabaret\", \"New Wave\", \"Psychadelic\", \"Rave\", \"Showtunes\", \"Trailer\", \"Lo-Fi\", \"Tribal\", \"Acid Punk\", \"Acid Jazz\", \"Polka\", \"Retro\", \"Musical\", \"Rock & Roll\", \"Hard Rock\", \"Folk\", \"Folk-Rock\", \"National Folk\", \"Swing\", \"Fast Fusion\", \"Bebob\", \"Latin\", \"Revival\", \"Celtic\", \"Bluegrass\", \"Avantgarde\", \"Gothic Rock\", \"Progressive Rock\", \"Psychedelic Rock\", \"Symphonic Rock\", \"Slow Rock\", \"Big Band\", \"Chorus\", \"Easy Listening\", \"Acoustic\", \"Humour\", \"Speech\", \"Chanson\", \"Opera\", \"Chamber Music\", \"Sonata\", \"Symphony\", \"Booty Bass\", \"Primus\", \"Porn Groove\", \"Satire\", \"Slow Jam\", \"Club\", \"Tango\", \"Samba\", \"Folklore\", \"Ballad\", \"Power Ballad\", \"Rhythmic Soul\", \"Freestyle\", \"Duet\", \"Punk Rock\", \"Drum Solo\", \"Acapella\", \"Euro-House\", \"Dance Hall\"];\n\nmodule.exports = ID3v1TagReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ID3v2TagReader.js":"'use strict';\n\nvar MediaTagReader = require('./MediaTagReader');\nvar MediaFileReader = require('./MediaFileReader');\nvar ArrayFileReader = require('./ArrayFileReader');\nvar ID3v2FrameReader = require('./ID3v2FrameReader');\n\nconst ID3_HEADER_SIZE = 10;\n\nclass ID3v2TagReader extends MediaTagReader {\n  static getTagIdentifierByteRange() {\n    // ID3 header\n    return {\n      offset: 0,\n      length: ID3_HEADER_SIZE\n    };\n  }\n\n  static canReadTagFormat(tagIdentifier) {\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 3));\n    return id === 'ID3';\n  }\n\n  _loadData(mediaFileReader, callbacks) {\n    mediaFileReader.loadRange([6, 9], {\n      onSuccess: function () {\n        mediaFileReader.loadRange(\n        // The tag size does not include the header size.\n        [0, ID3_HEADER_SIZE + mediaFileReader.getSynchsafeInteger32At(6) - 1], callbacks);\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _parseData(data, tags) {\n    var offset = 0;\n    var major = data.getByteAt(offset + 3);\n    if (major > 4) {\n      return { \"type\": \"ID3\", \"version\": \">2.4\", \"tags\": {} };\n    }\n    var revision = data.getByteAt(offset + 4);\n    var unsynch = data.isBitSetAt(offset + 5, 7);\n    var xheader = data.isBitSetAt(offset + 5, 6);\n    var xindicator = data.isBitSetAt(offset + 5, 5);\n    var size = data.getSynchsafeInteger32At(offset + 6);\n    offset += 10;\n\n    if (xheader) {\n      // TODO: support 2.4\n      var xheadersize = data.getLongAt(offset, true);\n      // The 'Extended header size', currently 6 or 10 bytes, excludes itself.\n      offset += xheadersize + 4;\n    }\n\n    var id3 = {\n      \"type\": \"ID3\",\n      \"version\": '2.' + major + '.' + revision,\n      \"major\": major,\n      \"revision\": revision,\n      \"flags\": {\n        \"unsynchronisation\": unsynch,\n        \"extended_header\": xheader,\n        \"experimental_indicator\": xindicator,\n        // TODO: footer_present\n        \"footer_present\": false\n      },\n      \"size\": size,\n      \"tags\": {}\n    };\n\n    var frames = this._readFrames(offset, size + 10 /*header size*/, data, id3, tags);\n    // create shortcuts for most common data.\n    for (var name in SHORTCUTS) if (SHORTCUTS.hasOwnProperty(name)) {\n      var frameData = this._getFrameData(frames, SHORTCUTS[name]);\n      if (frameData) {\n        id3.tags[name] = frameData;\n      }\n    }\n\n    for (var frame in frames) if (frames.hasOwnProperty(frame)) {\n      id3.tags[frame] = frames[frame];\n    }\n\n    return id3;\n  }\n\n  _getUnsyncFileReader(data, offset, size) {\n    var frameData = data.getBytesAt(offset, size);\n    for (var i = 0; i < frameData.length - 1; i++) {\n      if (frameData[i] === 0xff && frameData[i + 1] === 0x00) {\n        frameData.splice(i + 1, 1);\n      }\n    }\n\n    return new ArrayFileReader(frameData);\n  }\n\n  /**\n   * All the frames consists of a frame header followed by one or more fields\n   * containing the actual information.\n   * The frame ID made out of the characters capital A-Z and 0-9. Identifiers\n   * beginning with \"X\", \"Y\" and \"Z\" are for experimental use and free for\n   * everyone to use, without the need to set the experimental bit in the tag\n   * header. Have in mind that someone else might have used the same identifier\n   * as you. All other identifiers are either used or reserved for future use.\n   * The frame ID is followed by a size descriptor, making a total header size\n   * of ten bytes in every frame. The size is calculated as frame size excluding\n   * frame header (frame size - 10).\n   */\n  _readFrames(offset, end, data, id3header, tags) {\n    var frames = {};\n\n    if (tags) {\n      tags = this._expandShortcutTags(tags);\n    }\n\n    while (offset < end) {\n      var header = this._readFrameHeader(data, offset, id3header);\n      var frameId = header.id;\n\n      // No frame ID sometimes means it's the last frame (GTFO).\n      if (!frameId) {\n        break;\n      }\n\n      var flags = header.flags;\n      var frameSize = header.size;\n      var frameDataOffset = offset + header.headerSize;\n      var frameData = data;\n\n      // advance data offset to the next frame data\n      offset += header.headerSize + header.size;\n\n      // skip unwanted tags\n      if (tags && tags.indexOf(frameId) === -1) {\n        continue;\n      }\n\n      var unsyncData;\n      if (id3header.flags.unsynchronisation || flags && flags.format.unsynchronisation) {\n        frameData = this._getUnsyncFileReader(frameData, frameDataOffset, frameSize);\n        frameDataOffset = 0;\n        frameSize = frameData.getSize();\n      }\n\n      // the first 4 bytes are the real data size\n      // (after unsynchronisation && encryption)\n      if (flags && flags.format.data_length_indicator) {\n        // var frameDataSize = frameData.getSynchsafeInteger32At(frameDataOffset);\n        frameDataOffset += 4;\n        frameSize -= 4;\n      }\n\n      var readFrameFunc = ID3v2FrameReader.getFrameReaderFunction(frameId);\n      var parsedData = readFrameFunc ? readFrameFunc(frameDataOffset, frameSize, frameData, flags) : null;\n      var desc = this._getFrameDescription(frameId);\n\n      var frame = {\n        id: frameId,\n        size: frameSize,\n        description: desc,\n        data: parsedData\n      };\n\n      if (frameId in frames) {\n        if (frames[frameId].id) {\n          frames[frameId] = [frames[frameId]];\n        }\n        frames[frameId].push(frame);\n      } else {\n        frames[frameId] = frame;\n      }\n    }\n\n    return frames;\n  }\n\n  _readFrameHeader(data, offset, id3header) {\n    var major = id3header.major;\n    var flags = null;\n\n    switch (major) {\n      case 2:\n        var frameId = data.getStringAt(offset, 3);\n        var frameSize = data.getInteger24At(offset + 3, true);\n        var frameHeaderSize = 6;\n        break;\n\n      case 3:\n        var frameId = data.getStringAt(offset, 4);\n        var frameSize = data.getLongAt(offset + 4, true);\n        var frameHeaderSize = 10;\n        break;\n\n      case 4:\n        var frameId = data.getStringAt(offset, 4);\n        var frameSize = data.getSynchsafeInteger32At(offset + 4);\n        var frameHeaderSize = 10;\n        break;\n    }\n\n    if (frameId == String.fromCharCode(0, 0, 0) || frameId == String.fromCharCode(0, 0, 0, 0)) {\n      frameId = \"\";\n    }\n\n    // if frameId is empty then it's the last frame\n    if (frameId) {\n      // read frame message and format flags\n      if (major > 2) {\n        flags = this._readFrameFlags(data, offset + 8);\n      }\n    }\n\n    return {\n      \"id\": frameId || \"\",\n      \"size\": frameSize || 0,\n      \"headerSize\": frameHeaderSize || 0,\n      \"flags\": flags\n    };\n  }\n\n  _readFrameFlags(data, offset) {\n    return {\n      message: {\n        tag_alter_preservation: data.isBitSetAt(offset, 6),\n        file_alter_preservation: data.isBitSetAt(offset, 5),\n        read_only: data.isBitSetAt(offset, 4)\n      },\n      format: {\n        grouping_identity: data.isBitSetAt(offset + 1, 7),\n        compression: data.isBitSetAt(offset + 1, 3),\n        encryption: data.isBitSetAt(offset + 1, 2),\n        unsynchronisation: data.isBitSetAt(offset + 1, 1),\n        data_length_indicator: data.isBitSetAt(offset + 1, 0)\n      }\n    };\n  }\n\n  _getFrameData(frames, ids) {\n    for (var i = 0, id; id = ids[i]; i++) {\n      if (id in frames) {\n        return frames[id].data;\n      }\n    }\n  }\n\n  _getFrameDescription(frameId) {\n    if (frameId in FRAME_DESCRIPTIONS) {\n      return FRAME_DESCRIPTIONS[frameId];\n    } else {\n      return 'Unknown';\n    }\n  }\n\n  getShortcuts() {\n    return SHORTCUTS;\n  }\n}\n\nconst FRAME_DESCRIPTIONS = {\n  // v2.2\n  \"BUF\": \"Recommended buffer size\",\n  \"CNT\": \"Play counter\",\n  \"COM\": \"Comments\",\n  \"CRA\": \"Audio encryption\",\n  \"CRM\": \"Encrypted meta frame\",\n  \"ETC\": \"Event timing codes\",\n  \"EQU\": \"Equalization\",\n  \"GEO\": \"General encapsulated object\",\n  \"IPL\": \"Involved people list\",\n  \"LNK\": \"Linked information\",\n  \"MCI\": \"Music CD Identifier\",\n  \"MLL\": \"MPEG location lookup table\",\n  \"PIC\": \"Attached picture\",\n  \"POP\": \"Popularimeter\",\n  \"REV\": \"Reverb\",\n  \"RVA\": \"Relative volume adjustment\",\n  \"SLT\": \"Synchronized lyric/text\",\n  \"STC\": \"Synced tempo codes\",\n  \"TAL\": \"Album/Movie/Show title\",\n  \"TBP\": \"BPM (Beats Per Minute)\",\n  \"TCM\": \"Composer\",\n  \"TCO\": \"Content type\",\n  \"TCR\": \"Copyright message\",\n  \"TDA\": \"Date\",\n  \"TDY\": \"Playlist delay\",\n  \"TEN\": \"Encoded by\",\n  \"TFT\": \"File type\",\n  \"TIM\": \"Time\",\n  \"TKE\": \"Initial key\",\n  \"TLA\": \"Language(s)\",\n  \"TLE\": \"Length\",\n  \"TMT\": \"Media type\",\n  \"TOA\": \"Original artist(s)/performer(s)\",\n  \"TOF\": \"Original filename\",\n  \"TOL\": \"Original Lyricist(s)/text writer(s)\",\n  \"TOR\": \"Original release year\",\n  \"TOT\": \"Original album/Movie/Show title\",\n  \"TP1\": \"Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group\",\n  \"TP2\": \"Band/Orchestra/Accompaniment\",\n  \"TP3\": \"Conductor/Performer refinement\",\n  \"TP4\": \"Interpreted, remixed, or otherwise modified by\",\n  \"TPA\": \"Part of a set\",\n  \"TPB\": \"Publisher\",\n  \"TRC\": \"ISRC (International Standard Recording Code)\",\n  \"TRD\": \"Recording dates\",\n  \"TRK\": \"Track number/Position in set\",\n  \"TSI\": \"Size\",\n  \"TSS\": \"Software/hardware and settings used for encoding\",\n  \"TT1\": \"Content group description\",\n  \"TT2\": \"Title/Songname/Content description\",\n  \"TT3\": \"Subtitle/Description refinement\",\n  \"TXT\": \"Lyricist/text writer\",\n  \"TXX\": \"User defined text information frame\",\n  \"TYE\": \"Year\",\n  \"UFI\": \"Unique file identifier\",\n  \"ULT\": \"Unsychronized lyric/text transcription\",\n  \"WAF\": \"Official audio file webpage\",\n  \"WAR\": \"Official artist/performer webpage\",\n  \"WAS\": \"Official audio source webpage\",\n  \"WCM\": \"Commercial information\",\n  \"WCP\": \"Copyright/Legal information\",\n  \"WPB\": \"Publishers official webpage\",\n  \"WXX\": \"User defined URL link frame\",\n  // v2.3\n  \"AENC\": \"Audio encryption\",\n  \"APIC\": \"Attached picture\",\n  \"ASPI\": \"Audio seek point index\",\n  \"COMM\": \"Comments\",\n  \"COMR\": \"Commercial frame\",\n  \"ENCR\": \"Encryption method registration\",\n  \"EQU2\": \"Equalisation (2)\",\n  \"EQUA\": \"Equalization\",\n  \"ETCO\": \"Event timing codes\",\n  \"GEOB\": \"General encapsulated object\",\n  \"GRID\": \"Group identification registration\",\n  \"IPLS\": \"Involved people list\",\n  \"LINK\": \"Linked information\",\n  \"MCDI\": \"Music CD identifier\",\n  \"MLLT\": \"MPEG location lookup table\",\n  \"OWNE\": \"Ownership frame\",\n  \"PRIV\": \"Private frame\",\n  \"PCNT\": \"Play counter\",\n  \"POPM\": \"Popularimeter\",\n  \"POSS\": \"Position synchronisation frame\",\n  \"RBUF\": \"Recommended buffer size\",\n  \"RVA2\": \"Relative volume adjustment (2)\",\n  \"RVAD\": \"Relative volume adjustment\",\n  \"RVRB\": \"Reverb\",\n  \"SEEK\": \"Seek frame\",\n  \"SYLT\": \"Synchronized lyric/text\",\n  \"SYTC\": \"Synchronized tempo codes\",\n  \"TALB\": \"Album/Movie/Show title\",\n  \"TBPM\": \"BPM (beats per minute)\",\n  \"TCOM\": \"Composer\",\n  \"TCON\": \"Content type\",\n  \"TCOP\": \"Copyright message\",\n  \"TDAT\": \"Date\",\n  \"TDLY\": \"Playlist delay\",\n  \"TDRC\": \"Recording time\",\n  \"TDRL\": \"Release time\",\n  \"TDTG\": \"Tagging time\",\n  \"TENC\": \"Encoded by\",\n  \"TEXT\": \"Lyricist/Text writer\",\n  \"TFLT\": \"File type\",\n  \"TIME\": \"Time\",\n  \"TIPL\": \"Involved people list\",\n  \"TIT1\": \"Content group description\",\n  \"TIT2\": \"Title/songname/content description\",\n  \"TIT3\": \"Subtitle/Description refinement\",\n  \"TKEY\": \"Initial key\",\n  \"TLAN\": \"Language(s)\",\n  \"TLEN\": \"Length\",\n  \"TMCL\": \"Musician credits list\",\n  \"TMED\": \"Media type\",\n  \"TMOO\": \"Mood\",\n  \"TOAL\": \"Original album/movie/show title\",\n  \"TOFN\": \"Original filename\",\n  \"TOLY\": \"Original lyricist(s)/text writer(s)\",\n  \"TOPE\": \"Original artist(s)/performer(s)\",\n  \"TORY\": \"Original release year\",\n  \"TOWN\": \"File owner/licensee\",\n  \"TPE1\": \"Lead performer(s)/Soloist(s)\",\n  \"TPE2\": \"Band/orchestra/accompaniment\",\n  \"TPE3\": \"Conductor/performer refinement\",\n  \"TPE4\": \"Interpreted, remixed, or otherwise modified by\",\n  \"TPOS\": \"Part of a set\",\n  \"TPRO\": \"Produced notice\",\n  \"TPUB\": \"Publisher\",\n  \"TRCK\": \"Track number/Position in set\",\n  \"TRDA\": \"Recording dates\",\n  \"TRSN\": \"Internet radio station name\",\n  \"TRSO\": \"Internet radio station owner\",\n  \"TSOA\": \"Album sort order\",\n  \"TSOP\": \"Performer sort order\",\n  \"TSOT\": \"Title sort order\",\n  \"TSIZ\": \"Size\",\n  \"TSRC\": \"ISRC (international standard recording code)\",\n  \"TSSE\": \"Software/Hardware and settings used for encoding\",\n  \"TSST\": \"Set subtitle\",\n  \"TYER\": \"Year\",\n  \"TXXX\": \"User defined text information frame\",\n  \"UFID\": \"Unique file identifier\",\n  \"USER\": \"Terms of use\",\n  \"USLT\": \"Unsychronized lyric/text transcription\",\n  \"WCOM\": \"Commercial information\",\n  \"WCOP\": \"Copyright/Legal information\",\n  \"WOAF\": \"Official audio file webpage\",\n  \"WOAR\": \"Official artist/performer webpage\",\n  \"WOAS\": \"Official audio source webpage\",\n  \"WORS\": \"Official internet radio station homepage\",\n  \"WPAY\": \"Payment\",\n  \"WPUB\": \"Publishers official webpage\",\n  \"WXXX\": \"User defined URL link frame\"\n};\n\nconst SHORTCUTS = {\n  \"title\": [\"TIT2\", \"TT2\"],\n  \"artist\": [\"TPE1\", \"TP1\"],\n  \"album\": [\"TALB\", \"TAL\"],\n  \"year\": [\"TYER\", \"TYE\"],\n  \"comment\": [\"COMM\", \"COM\"],\n  \"track\": [\"TRCK\", \"TRK\"],\n  \"genre\": [\"TCON\", \"TCO\"],\n  \"picture\": [\"APIC\", \"PIC\"],\n  \"lyrics\": [\"USLT\", \"ULT\"]\n};\n\nmodule.exports = ID3v2TagReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ID3v2FrameReader.js":"'use strict';\n\nvar MediaFileReader = require('./MediaFileReader');\n\nvar ID3v2FrameReader = {\n  getFrameReaderFunction: function (frameId) {\n    if (frameId in frameReaderFunctions) {\n      return frameReaderFunctions[frameId];\n    } else if (frameId[0] === \"T\") {\n      // All frame ids starting with T are text tags.\n      return frameReaderFunctions[\"T*\"];\n    } else if (frameId[0] === \"W\") {\n      // All frame ids starting with W are url tags.\n      return frameReaderFunctions[\"W*\"];\n    } else {\n      return null;\n    }\n  }\n};\n\nvar frameReaderFunctions = {};\n\nframeReaderFunctions['APIC'] = function readPictureFrame(offset, length, data, flags, majorVersion) {\n  majorVersion = majorVersion || '3';\n\n  var start = offset;\n  var charset = getTextEncoding(data.getByteAt(offset));\n  switch (majorVersion) {\n    case '2':\n      var format = data.getStringAt(offset + 1, 3);\n      offset += 4;\n      break;\n\n    case '3':\n    case '4':\n      var format = data.getStringWithCharsetAt(offset + 1, length - 1);\n      offset += 1 + format.bytesReadCount;\n      break;\n\n    default:\n      throw new Error(\"Couldn't read ID3v2 major version.\");\n  }\n  var bite = data.getByteAt(offset, 1);\n  var type = PICTURE_TYPE[bite];\n  var desc = data.getStringWithCharsetAt(offset + 1, length - (offset - start) - 1, charset);\n\n  offset += 1 + desc.bytesReadCount;\n\n  return {\n    \"format\": format.toString(),\n    \"type\": type,\n    \"description\": desc.toString(),\n    \"data\": data.getBytesAt(offset, start + length - offset)\n  };\n};\n\nframeReaderFunctions['COMM'] = function readCommentsFrame(offset, length, data, flags, majorVersion) {\n  var start = offset;\n  var charset = getTextEncoding(data.getByteAt(offset));\n  var language = data.getStringAt(offset + 1, 3);\n  var shortdesc = data.getStringWithCharsetAt(offset + 4, length - 4, charset);\n\n  offset += 4 + shortdesc.bytesReadCount;\n  var text = data.getStringWithCharsetAt(offset, start + length - offset, charset);\n\n  return {\n    language: language,\n    short_description: shortdesc.toString(),\n    text: text.toString()\n  };\n};\n\nframeReaderFunctions['COM'] = frameReaderFunctions['COMM'];\n\nframeReaderFunctions['PIC'] = function (offset, length, data, flags, majorVersion) {\n  return frameReaderFunctions['APIC'](offset, length, data, flags, '2');\n};\n\nframeReaderFunctions['PCNT'] = function readCounterFrame(offset, length, data, flags, majorVersion) {\n  // FIXME: implement the rest of the spec\n  return data.getLongAt(offset, false);\n};\n\nframeReaderFunctions['CNT'] = frameReaderFunctions['PCNT'];\n\nframeReaderFunctions['T*'] = function readTextFrame(offset, length, data, flags, majorVersion) {\n  var charset = getTextEncoding(data.getByteAt(offset));\n\n  return data.getStringWithCharsetAt(offset + 1, length - 1, charset).toString();\n};\n\nframeReaderFunctions['TXXX'] = function readTextFrame(offset, length, data, flags, majorVersion) {\n  var charset = getTextEncoding(data.getByteAt(offset));\n\n  return getUserDefinedFields(offset, length, data, charset);\n};\n\nframeReaderFunctions['W*'] = function readUrlFrame(offset, length, data, flags, majorVersion) {\n  // charset is only defined for user-defined URL link frames (http://id3.org/id3v2.3.0#User_defined_URL_link_frame)\n  // for the other URL link frames it is always iso-8859-1\n  var charset = getTextEncoding(data.getByteAt(offset));\n\n  if (charset !== undefined) {\n    return getUserDefinedFields(offset, length, data, charset);\n  } else {\n    return data.getStringWithCharsetAt(offset, length, charset).toString();\n  }\n};\n\nframeReaderFunctions['TCON'] = function readGenreFrame(offset, length, data, flags) {\n  var text = frameReaderFunctions['T*'].apply(this, arguments);\n  return text.replace(/^\\(\\d+\\)/, '');\n};\n\nframeReaderFunctions['TCO'] = frameReaderFunctions['TCON'];\n\nframeReaderFunctions['USLT'] = function readLyricsFrame(offset, length, data, flags, majorVersion) {\n  var start = offset;\n  var charset = getTextEncoding(data.getByteAt(offset));\n  var language = data.getStringAt(offset + 1, 3);\n  var descriptor = data.getStringWithCharsetAt(offset + 4, length - 4, charset);\n\n  offset += 4 + descriptor.bytesReadCount;\n  var lyrics = data.getStringWithCharsetAt(offset, start + length - offset, charset);\n\n  return {\n    language: language,\n    descriptor: descriptor.toString(),\n    lyrics: lyrics.toString()\n  };\n};\n\nframeReaderFunctions['ULT'] = frameReaderFunctions['USLT'];\n\nfunction getTextEncoding(bite) {\n  var charset;\n\n  switch (bite) {\n    case 0x00:\n      charset = 'iso-8859-1';\n      break;\n\n    case 0x01:\n      charset = 'utf-16';\n      break;\n\n    case 0x02:\n      charset = 'utf-16be';\n      break;\n\n    case 0x03:\n      charset = 'utf-8';\n      break;\n  }\n\n  return charset;\n}\n\n// Handles reading description/data from either http://id3.org/id3v2.3.0#User_defined_text_information_frame\n// and http://id3.org/id3v2.3.0#User_defined_URL_link_frame\nfunction getUserDefinedFields(offset, length, data, charset) {\n  var userDesc = data.getStringWithCharsetAt(offset + 1, length - 1, charset);\n  var userDefinedData = data.getStringWithCharsetAt(offset + 1 + userDesc.bytesReadCount, length - 1 - userDesc.bytesReadCount);\n\n  return {\n    user_description: userDesc.toString(),\n    data: userDefinedData.toString()\n  };\n}\n\nvar PICTURE_TYPE = [\"Other\", \"32x32 pixels 'file icon' (PNG only)\", \"Other file icon\", \"Cover (front)\", \"Cover (back)\", \"Leaflet page\", \"Media (e.g. label side of CD)\", \"Lead artist/lead performer/soloist\", \"Artist/performer\", \"Conductor\", \"Band/Orchestra\", \"Composer\", \"Lyricist/text writer\", \"Recording Location\", \"During recording\", \"During performance\", \"Movie/video screen capture\", \"A bright coloured fish\", \"Illustration\", \"Band/artist logotype\", \"Publisher/Studio logotype\"];\n\nmodule.exports = ID3v2FrameReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/MP4TagReader.js":"/**\n * Support for iTunes-style m4a tags\n * See:\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html\n * Authored by Joshua Kifer <joshua.kifer gmail.com>\n * \n */\n'use strict';\n\nvar MediaTagReader = require('./MediaTagReader');\nvar MediaFileReader = require('./MediaFileReader');\n\nclass MP4TagReader extends MediaTagReader {\n  static getTagIdentifierByteRange() {\n    // The tag identifier is located in [4, 8] but since we'll need to reader\n    // the header of the first block anyway, we load it instead to avoid\n    // making two requests.\n    return {\n      offset: 0,\n      length: 16\n    };\n  }\n\n  static canReadTagFormat(tagIdentifier) {\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(4, 8));\n    return id === \"ftyp\";\n  }\n\n  _loadData(mediaFileReader, callbacks) {\n    // MP4 metadata isn't located in a specific location of the file. Roughly\n    // speaking, it's composed of blocks chained together like a linked list.\n    // These blocks are called atoms (or boxes).\n    // Each atom of the list can have its own child linked list. Atoms in this\n    // situation do not possess any data and are called \"container\" as they only\n    // contain other atoms.\n    // Other atoms represent a particular set of data, like audio, video or\n    // metadata. In order to find and load all the interesting atoms we need\n    // to traverse the entire linked list of atoms and only load the ones\n    // associated with metadata.\n    // The metadata atoms can be find under the \"moov.udta.meta.ilst\" hierarchy.\n\n    var self = this;\n    // Load the header of the first atom\n    mediaFileReader.loadRange([0, 16], {\n      onSuccess: function () {\n        self._loadAtom(mediaFileReader, 0, \"\", callbacks);\n      },\n      onError: callbacks.onError\n    });\n  }\n\n  _loadAtom(mediaFileReader, offset, parentAtomFullName, callbacks) {\n    if (offset >= mediaFileReader.getSize()) {\n      callbacks.onSuccess();\n      return;\n    }\n\n    var self = this;\n    // 8 is the size of the atomSize and atomName fields.\n    // When reading the current block we always read 8 more bytes in order\n    // to also read the header of the next block.\n    var atomSize = mediaFileReader.getLongAt(offset, true);\n    if (atomSize == 0 || isNaN(atomSize)) {\n      callbacks.onSuccess();\n      return;\n    }\n    var atomName = mediaFileReader.getStringAt(offset + 4, 4);\n    // console.log(parentAtomFullName, atomName, atomSize);\n    // Container atoms (no actual data)\n    if (this._isContainerAtom(atomName)) {\n      if (atomName == \"meta\") {\n        // The \"meta\" atom breaks convention and is a container with data.\n        offset += 4; // next_item_id (uint32)\n      }\n      var atomFullName = (parentAtomFullName ? parentAtomFullName + \".\" : \"\") + atomName;\n      if (atomFullName === \"moov.udta.meta.ilst\") {\n        mediaFileReader.loadRange([offset, offset + atomSize], callbacks);\n      } else {\n        mediaFileReader.loadRange([offset + 8, offset + 8 + 8], {\n          onSuccess: function () {\n            self._loadAtom(mediaFileReader, offset + 8, atomFullName, callbacks);\n          },\n          onError: callbacks.onError\n        });\n      }\n    } else {\n      mediaFileReader.loadRange([offset + atomSize, offset + atomSize + 8], {\n        onSuccess: function () {\n          self._loadAtom(mediaFileReader, offset + atomSize, parentAtomFullName, callbacks);\n        },\n        onError: callbacks.onError\n      });\n    }\n  }\n\n  _isContainerAtom(atomName) {\n    return [\"moov\", \"udta\", \"meta\", \"ilst\"].indexOf(atomName) >= 0;\n  }\n\n  _canReadAtom(atomName) {\n    return atomName !== \"----\";\n  }\n\n  _parseData(data, tagsToRead) {\n    var tags = {};\n\n    tagsToRead = this._expandShortcutTags(tagsToRead);\n    this._readAtom(tags, data, 0, data.getSize(), tagsToRead);\n\n    // create shortcuts for most common data.\n    for (var name in SHORTCUTS) if (SHORTCUTS.hasOwnProperty(name)) {\n      var tag = tags[SHORTCUTS[name]];\n      if (tag) {\n        if (name === \"track\") {\n          tags[name] = tag.data.track;\n        } else {\n          tags[name] = tag.data;\n        }\n      }\n    }\n\n    return {\n      \"type\": \"MP4\",\n      \"ftyp\": data.getStringAt(8, 4),\n      \"version\": data.getLongAt(12, true),\n      \"tags\": tags\n    };\n  }\n\n  _readAtom(tags, data, offset, length, tagsToRead, parentAtomFullName, indent) {\n    indent = indent === undefined ? \"\" : indent + \"  \";\n\n    var seek = offset;\n    while (seek < offset + length) {\n      var atomSize = data.getLongAt(seek, true);\n      if (atomSize == 0) {\n        return;\n      }\n      var atomName = data.getStringAt(seek + 4, 4);\n\n      // console.log(seek, parentAtomFullName, atomName, atomSize);\n      if (this._isContainerAtom(atomName)) {\n        if (atomName == \"meta\") {\n          seek += 4; // next_item_id (uint32)\n        }\n        var atomFullName = (parentAtomFullName ? parentAtomFullName + \".\" : \"\") + atomName;\n        this._readAtom(tags, data, seek + 8, atomSize - 8, tagsToRead, atomFullName, indent);\n        return;\n      }\n\n      // Value atoms\n      if ((!tagsToRead || tagsToRead.indexOf(atomName) >= 0) && parentAtomFullName === \"moov.udta.meta.ilst\" && this._canReadAtom(atomName)) {\n        tags[atomName] = this._readMetadataAtom(data, seek);\n      }\n\n      seek += atomSize;\n    }\n  }\n\n  _readMetadataAtom(data, offset) {\n    // 16: name + size + \"data\" + size (4 bytes each)\n    const METADATA_HEADER = 16;\n\n    var atomSize = data.getLongAt(offset, true);\n    var atomName = data.getStringAt(offset + 4, 4);\n\n    var klass = data.getInteger24At(offset + METADATA_HEADER + 1, true);\n    var type = TYPES[klass];\n    var atomData;\n\n    if (atomName == \"trkn\") {\n      atomData = {\n        \"track\": data.getByteAt(offset + METADATA_HEADER + 11),\n        \"total\": data.getByteAt(offset + METADATA_HEADER + 13)\n      };\n    } else {\n      // 4: atom version (1 byte) + atom flags (3 bytes)\n      // 4: NULL (usually locale indicator)\n      var atomHeader = METADATA_HEADER + 4 + 4;\n      var dataStart = offset + atomHeader;\n      var dataLength = atomSize - atomHeader;\n      var atomData;\n\n      // Workaround for covers being parsed as 'uint8' type despite being an 'covr' atom\n      if (atomName === 'covr' && type === 'uint8') {\n        type = 'jpeg';\n      }\n\n      switch (type) {\n        case \"text\":\n          atomData = data.getStringWithCharsetAt(dataStart, dataLength, \"utf-8\").toString();\n          break;\n\n        case \"uint8\":\n          atomData = data.getShortAt(dataStart, false);\n          break;\n\n        case \"int\":\n        case \"uint\":\n          // Though the QuickTime spec doesn't state it, there are 64-bit values\n          // such as plID (Playlist/Collection ID). With its single 64-bit floating\n          // point number type, these are hard to parse and pass in JavaScript.\n          // The high word of plID seems to always be zero, so, as this is the\n          // only current 64-bit atom handled, it is parsed from its 32-bit\n          // low word as an unsigned long.\n          //\n          var intReader = type == 'int' ? dataLength == 1 ? data.getSByteAt : dataLength == 2 ? data.getSShortAt : dataLength == 4 ? data.getSLongAt : data.getLongAt : dataLength == 1 ? data.getByteAt : dataLength == 2 ? data.getShortAt : data.getLongAt;\n\n          atomData = intReader.call(data, dataStart + (dataLength == 8 ? 4 : 0), true);\n          break;\n\n        case \"jpeg\":\n        case \"png\":\n          atomData = {\n            \"format\": \"image/\" + type,\n            \"data\": data.getBytesAt(dataStart, dataLength)\n          };\n          break;\n      }\n    }\n\n    return {\n      id: atomName,\n      size: atomSize,\n      description: ATOM_DESCRIPTIONS[atomName] || \"Unknown\",\n      data: atomData\n    };\n  }\n\n  getShortcuts() {\n    return SHORTCUTS;\n  }\n}\n\n/*\n * https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n*/\nconst TYPES = {\n  \"0\": \"uint8\",\n  \"1\": \"text\",\n  \"13\": \"jpeg\",\n  \"14\": \"png\",\n  \"21\": \"int\",\n  \"22\": \"uint\"\n};\n\nconst ATOM_DESCRIPTIONS = {\n  \"alb\": \"Album\",\n  \"ART\": \"Artist\",\n  \"aART\": \"Album Artist\",\n  \"day\": \"Release Date\",\n  \"nam\": \"Title\",\n  \"gen\": \"Genre\",\n  \"gnre\": \"Genre\",\n  \"trkn\": \"Track Number\",\n  \"wrt\": \"Composer\",\n  \"too\": \"Encoding Tool\",\n  \"enc\": \"Encoded By\",\n  \"cprt\": \"Copyright\",\n  \"covr\": \"Cover Art\",\n  \"grp\": \"Grouping\",\n  \"keyw\": \"Keywords\",\n  \"lyr\": \"Lyrics\",\n  \"cmt\": \"Comment\",\n  \"tmpo\": \"Tempo\",\n  \"cpil\": \"Compilation\",\n  \"disk\": \"Disc Number\",\n  \"tvsh\": \"TV Show Name\",\n  \"tven\": \"TV Episode ID\",\n  \"tvsn\": \"TV Season\",\n  \"tves\": \"TV Episode\",\n  \"tvnn\": \"TV Network\",\n  \"desc\": \"Description\",\n  \"ldes\": \"Long Description\",\n  \"sonm\": \"Sort Name\",\n  \"soar\": \"Sort Artist\",\n  \"soaa\": \"Sort Album\",\n  \"soco\": \"Sort Composer\",\n  \"sosn\": \"Sort Show\",\n  \"purd\": \"Purchase Date\",\n  \"pcst\": \"Podcast\",\n  \"purl\": \"Podcast URL\",\n  \"catg\": \"Category\",\n  \"hdvd\": \"HD Video\",\n  \"stik\": \"Media Type\",\n  \"rtng\": \"Content Rating\",\n  \"pgap\": \"Gapless Playback\",\n  \"apID\": \"Purchase Account\",\n  \"sfID\": \"Country Code\",\n  \"atID\": \"Artist ID\",\n  \"cnID\": \"Catalog ID\",\n  \"plID\": \"Collection ID\",\n  \"geID\": \"Genre ID\",\n  \"xid \": \"Vendor Information\",\n  \"flvr\": \"Codec Flavor\"\n};\n\nconst UNSUPPORTED_ATOMS = {\n  \"----\": 1\n};\n\nconst SHORTCUTS = {\n  \"title\": \"nam\",\n  \"artist\": \"ART\",\n  \"album\": \"alb\",\n  \"year\": \"day\",\n  \"comment\": \"cmt\",\n  \"track\": \"trkn\",\n  \"genre\": \"gen\",\n  \"picture\": \"covr\",\n  \"lyrics\": \"lyr\"\n};\n\nmodule.exports = MP4TagReader;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ByteArrayUtils.js":"'use strict';\n\n/**\n * Converts a string to a binary array\n */\nconst bin = function (string) {\n  var binaryArray = new Array(string.length);\n  for (var i = 0; i < string.length; i++) {\n    binaryArray[i] = string.charCodeAt(i);\n  }\n  return binaryArray;\n};\n\n/**\n * Pads an array with \\0 until it is size length.\n */\nconst pad = function (array, size) {\n  for (var i = array.length; i < size; i++) {\n    array.push(0);\n  }\n  return array;\n};\n\n// The ID3v2 tag/frame size is encoded with four bytes where the most\n// significant bit (bit 7) is set to zero in every byte, making a total of 28\n// bits. The zeroed bits are ignored, so a 257 bytes long tag is represented\n// as $00 00 02 01.\nconst getSynchsafeInteger32 = function (number) {\n  // 0x7f = 0b01111111\n  return [number >> 21 & 0x7f, number >> 14 & 0x7f, number >> 7 & 0x7f, number & 0x7f];\n};\n\nconst getInteger32 = function (number) {\n  return [number >> 24 & 0xff, number >> 16 & 0xff, number >> 8 & 0xff, number & 0xff];\n};\n\nconst getInteger24 = function (number) {\n  return [number >> 16 & 0xff, number >> 8 & 0xff, number & 0xff];\n};\n\nmodule.exports = {\n  bin: bin,\n  pad: pad,\n  getSynchsafeInteger32: getSynchsafeInteger32,\n  getInteger32: getInteger32,\n  getInteger24: getInteger24\n};","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/ID3v2TagContents.js":"/**\n * This is only used for testing, but could be used for other purposes as\n * writing.\n *\n * http://id3.org/id3v2-00\n * http://id3.org/id3v2.3.0\n * http://id3.org/id3v2.4.0-structure\n *\n * TODO: Padding and Footer\n * \n */\n'use strict';\n\nconst ByteArrayUtils = require('./ByteArrayUtils');\nconst bin = ByteArrayUtils.bin;\nconst getSynchsafeInteger32 = ByteArrayUtils.getSynchsafeInteger32;\nconst getInteger32 = ByteArrayUtils.getInteger32;\nconst getInteger24 = ByteArrayUtils.getInteger24;\n\n// Offsets\nconst FLAGS = 5;\nconst SIZE = 6;\nconst EXTENDED_HEADER = 10;\nconst EXTENDED_FLAGS_V3 = 14;\nconst EXTENDED_FLAGS_V4 = 15;\nconst START_EXTENDED_DATA_V3 = 20;\nconst START_EXTENDED_DATA_V4 = 16;\n// Sizes\nconst HEADER_SIZE = 10;\n\nclass ID3v2TagContents {\n\n  constructor(major, revision) {\n    if (major < 2 || major > 4) {\n      throw new Error('Major version not supported');\n    }\n\n    this._major = major;\n    this._revision = revision;\n    this._contents = [].concat(bin(\"ID3\"), [major, revision], [0], // flags\n    [0, 0, 0, 0] // size\n    );\n    this._frames = {};\n    this._updateSize();\n    this._extendedHeader = {\n      // key: length\n      'UPDATE': 0,\n      'CRC': 0,\n      'RESTRICTIONS': 0\n    };\n  }\n\n  toArray() {\n    return this._contents.slice(0);\n  }\n\n  setFlags(flags) {\n    var binaryFlags = 0;\n\n    if (flags.unsynchronisation) {\n      binaryFlags |= 1 << 7;\n    }\n    if (flags.extended_header) {\n      binaryFlags |= 1 << 6;\n    }\n    if (flags.experimental_indicator) {\n      binaryFlags |= 1 << 5;\n    }\n    if (flags.footer_present) {\n      binaryFlags |= 1 << 4;\n    }\n\n    this._contents[FLAGS] = binaryFlags;\n    return this;\n  }\n\n  setCrc(crc) {\n    if (!this._hasExtendedHeader) {\n      this._initExtendedHeader();\n    }\n\n    if (this._major === 3) {\n      this._setBitAtOffset(EXTENDED_FLAGS_V3, 7);\n      this._setData(START_EXTENDED_DATA_V3, crc);\n      this._extendedHeader['CRC'] = crc.length;\n      // Update extended header size.\n      this._setData(EXTENDED_HEADER, getInteger32(10));\n    } else if (this._major === 4) {\n      this._setBitAtOffset(EXTENDED_FLAGS_V4, 5);\n      this._addExtendedHeaderData('CRC', crc);\n    }\n\n    this._updateSize();\n    return this;\n  }\n\n  setTagIsUpdate() {\n    if (!this._hasExtendedHeader) {\n      this._initExtendedHeader();\n    }\n\n    if (this._major === 4) {\n      this._setBitAtOffset(EXTENDED_FLAGS_V4, 6);\n      this._addExtendedHeaderData('UPDATE', []);\n    }\n\n    return this;\n  }\n\n  /**\n   * For some applications it might be desired to restrict a tag in more\n   * ways than imposed by the ID3v2 specification. Note that the\n   * presence of these restrictions does not affect how the tag is\n   * decoded, merely how it was restricted before encoding. If this flag\n   * is set the tag is restricted as follows:\n   *\n   *    Flag data length       $01\n   *    Restrictions           %ppqrrstt\n   *\n   * p - Tag size restrictions\n    *   00   No more than 128 frames and 1 MB total tag size.\n   *   01   No more than 64 frames and 128 KB total tag size.\n   *   10   No more than 32 frames and 40 KB total tag size.\n   *   11   No more than 32 frames and 4 KB total tag size.\n   *\n   * q - Text encoding restrictions\n   *\n   *   0    No restrictions\n   *   1    Strings are only encoded with ISO-8859-1 [ISO-8859-1] or\n   *        UTF-8 [UTF-8].\n   *\n   * r - Text fields size restrictions\n   *\n   *   00   No restrictions\n   *   01   No string is longer than 1024 characters.\n   *   10   No string is longer than 128 characters.\n   *   11   No string is longer than 30 characters.\n   *\n   *   Note that nothing is said about how many bytes is used to\n   *   represent those characters, since it is encoding dependent. If a\n   *   text frame consists of more than one string, the sum of the\n   *   strungs is restricted as stated.\n   *\n   * s - Image encoding restrictions\n   *\n   *   0   No restrictions\n   *   1   Images are encoded only with PNG [PNG] or JPEG [JFIF].\n   *\n   * t - Image size restrictions\n   *\n   *   00  No restrictions\n   *   01  All images are 256x256 pixels or smaller.\n   *   10  All images are 64x64 pixels or smaller.\n   *   11  All images are exactly 64x64 pixels, unless required\n   *       otherwise.\n   */\n  setTagRestrictions(size, textEncoding, textSize, imageEncoding, imageSize) {\n    if (!this._hasExtendedHeader) {\n      this._initExtendedHeader();\n    }\n\n    if (this._major === 4) {\n      this._setBitAtOffset(EXTENDED_FLAGS_V4, 4);\n      // 0x03 = 0b11\n      this._addExtendedHeaderData('RESTRICTIONS', [(size & 0x3) << 6 | (textEncoding & 0x1) << 5 | (textSize & 0x3) << 3 | (imageEncoding & 0x1) << 2 | (imageSize & 0x3) << 1]);\n    }\n\n    return this;\n  }\n\n  /**\n   * noFlagsDataLength - The data length if all flags were set to 0,\n   *   for instance, the length before compression and unsynchronisation.\n   *   This field is only needed when data_length_indicator flag is set.\n   */\n  addFrame(id, data, flags, noFlagsDataLength) {\n    var size = 0;\n    var frameFlags = [0, 0];\n    if (flags) {\n      flags.message = flags.message || {};\n      flags.format = flags.format || {};\n    }\n    data = data || [];\n\n    if (this._major === 2) {\n      size = getInteger24(data.length);\n    } else if (this._major === 3) {\n      size = getInteger32(data.length);\n      if (flags) {\n        frameFlags[0] |= (flags.message.tag_alter_preservation ? 1 : 0) << 7;\n        frameFlags[0] |= (flags.message.file_alter_preservation ? 1 : 0) << 6;\n        frameFlags[0] |= (flags.message.read_only ? 1 : 0) << 5;\n        frameFlags[1] |= (flags.format.compression ? 1 : 0) << 7;\n        frameFlags[1] |= (flags.format.encryption ? 1 : 0) << 6;\n        frameFlags[1] |= (flags.format.grouping_identify ? 1 : 0) << 5;\n      }\n    } else if (this._major === 4) {\n      var dataLength = data.length;\n      if (flags) {\n        frameFlags[0] |= (flags.message.tag_alter_preservation ? 1 : 0) << 6;\n        frameFlags[0] |= (flags.message.file_alter_preservation ? 1 : 0) << 5;\n        frameFlags[0] |= (flags.message.read_only ? 1 : 0) << 4;\n        frameFlags[1] |= (flags.format.grouping_identify ? 1 : 0) << 6;\n        frameFlags[1] |= (flags.format.compression ? 1 : 0) << 3;\n        frameFlags[1] |= (flags.format.encryption ? 1 : 0) << 2;\n        frameFlags[1] |= (flags.format.unsynchronisation ? 1 : 0) << 1;\n        frameFlags[1] |= flags.format.data_length_indicator ? 1 : 0;\n        if (flags.format.data_length_indicator) {\n          dataLength += 4;\n        }\n      }\n      size = getSynchsafeInteger32(dataLength);\n    } else {\n      throw Error(\"Major version not supported\");\n    }\n\n    var frame = [].concat(bin(id), size, frameFlags, flags && flags.format.data_length_indicator && noFlagsDataLength ? getSynchsafeInteger32(noFlagsDataLength) : [], data);\n    this._frames[id] = frame;\n    this._addData(this._nextFrameOffset, frame);\n\n    this._updateSize();\n    return this;\n  }\n\n  _addExtendedHeaderData(tagKey, tagData) {\n    var offset = START_EXTENDED_DATA_V4;\n\n    // Each flag that is set in the extended header has data attached, which\n    // comes in the order in which the flags are encountered (i.e. the data\n    // for flag 'b' comes before the data for flag 'c').\n    // _extendedHeader keeps track of which tag data we have by storing the\n    // size of the data. To know where to add a particular tag data we just need\n    // to sum all the data lengths of the tags that come before this tagKey\n    // because the keys in the map are in order.\n    for (var key in this._extendedHeader) {\n      if (this._extendedHeader.hasOwnProperty(key)) {\n        if (key === tagKey) {\n          break;\n        } else {\n          offset += this._extendedHeader[key];\n        }\n      }\n    }\n\n    var data = [tagData.length].concat(tagData);\n    this._extendedHeader[tagKey] = data.length;\n    this._addData(offset, data);\n  }\n\n  _initExtendedHeader() {\n    this._hasExtendedHeader = true;\n\n    if (this._major === 3) {\n      this._addData(EXTENDED_HEADER, [0, 0, 0, 6, // size\n      0, 0, // flags\n      0, 0, 0, 0 // padding\n      ]);\n    } else if (this._major === 4) {\n      this._addData(EXTENDED_HEADER, [].concat(getSynchsafeInteger32(6), // size\n      [1], // number of flag bytes\n      [0] // extended flags\n      ));\n    } else {\n      throw new Error(\"Version doesn't support extended header.\");\n    }\n  }\n\n  _updateSize() {\n    // Header (10 bytes) is not included in the size.\n    var size = 0;\n\n    if (this._hasExtendedHeader) {\n      // Extended header size\n      size += this._major === 4 ? 6 : 10;\n      // Extended header data size\n      for (var key in this._extendedHeader) {\n        if (this._extendedHeader.hasOwnProperty(key)) {\n          size += this._extendedHeader[key];\n        }\n      }\n    }\n\n    for (var frameId in this._frames) {\n      if (this._frames.hasOwnProperty(frameId)) {\n        size += this._frames[frameId].length;\n      }\n    }\n\n    this._nextFrameOffset = size + HEADER_SIZE;\n\n    this._size = size;\n    this._setData(SIZE, getSynchsafeInteger32(size));\n  }\n\n  _setBitAtOffset(offset, bit) {\n    var data = this._getData(offset, 1);\n    data[0] |= 1 << bit;\n    this._setData(offset, data);\n  }\n\n  _getData(offset, length) {\n    return this._contents.slice(offset, offset + length);\n  }\n\n  _setData(offset, data) {\n    this._contents.splice.apply(this._contents, [offset, data.length].concat(data));\n  }\n\n  _addData(offset, data) {\n    this._contents.splice.apply(this._contents, [offset, 0].concat(data));\n  }\n}\n\nmodule.exports = ID3v2TagContents;","/home/travis/build/npmtest/node-npmtest-jsmediatags/node_modules/jsmediatags/build2/MP4TagContents.js":"/**\n * This is only used for testing, but could be used for other purposes as\n * writing.\n *\n * http://atomicparsley.sourceforge.net/mpeg-4files.html\n *\n * \n */\n'use strict';\n\nconst ByteArrayUtils = require('./ByteArrayUtils');\nconst bin = ByteArrayUtils.bin;\nconst pad = ByteArrayUtils.pad;\nconst getInteger32 = ByteArrayUtils.getInteger32;\n\nclass MP4TagContents {\n\n  constructor(ftyp, atoms) {\n    this._atoms = [new Atom(\"ftyp\", pad(bin(ftyp), 24))].concat(atoms || []);\n  }\n\n  toArray() {\n    return this._atoms.reduce(function (array, atom) {\n      return array.concat(atom.toArray());\n    }, []);\n  }\n\n  static createAtom(atomName) {\n    return new Atom(atomName);\n  }\n\n  static createContainerAtom(atomName, atoms, data) {\n    return new Atom(atomName, data, atoms);\n  }\n\n  static createMetadataAtom(atomName, type, data) {\n    var klass = {\n      \"uint8\": 0,\n      \"uint8b\": 21, // Apple changed from 21 to 0 in latest versions\n      \"text\": 1,\n      \"jpeg\": 13,\n      \"png\": 14\n    }[type];\n\n    return this.createContainerAtom(atomName, [new Atom(\"data\", [].concat([0x00, 0x00, 0x00, klass], // 1 byte atom version + 3 byte atom flags\n    [0x00, 0x00, 0x00, 0x00], // NULL space\n    data))]);\n  }\n}\n\nclass Atom {\n\n  constructor(name, data, atoms) {\n    this._name = name;\n    this._data = data || [];\n    this._atoms = atoms || [];\n  }\n\n  toArray() {\n    var atomsArray = this._atoms.reduce(function (array, atom) {\n      return array.concat(atom.toArray());\n    }, []);\n    var length = 4 + this._name.length + this._data.length + atomsArray.length;\n\n    return [].concat(getInteger32(length), bin(this._name), this._data, atomsArray);\n  }\n}\n\nmodule.exports = MP4TagContents;"}